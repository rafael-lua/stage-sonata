local GAME_STATE = require "modules.game_state"
local hashes = require "modules.hashes"

go.property("player", hash(""))
go.property("block", msg.url())

function init(self)
    self.focused = false
    self.highlighted = false
    self.is_animating = false
    self.matched = false

    local animation = go.get("#cell_frame", "animation")
end

function update(self, dt)
    local currentAnimation = go.get("#cell_frame", "animation")

    if self.matched and currentAnimation ~= hashes.cell.animation.basic_match then
        msg.post(
            "#cell_frame", "play_animation", {
                id = hashes.cell.animation.basic_match
            }
        )
    elseif (not self.matched) then
        local non_focused_animation = self.highlighted and hashes.cell.animation.basic_h or hashes.cell.animation.basic

        if self.focused and currentAnimation ~= hashes.cell.animation.basic_2 then
            -- Change to the focused animation if cell is focused.
            msg.post(
                "#cell_frame", "play_animation", {
                    id = hashes.cell.animation.basic_2
                }
            )
        elseif not self.focused and currentAnimation ~= non_focused_animation then
            -- Change to the base animation (neutral or highlighted) if not focused.
            msg.post(
                "#cell_frame", "play_animation", {
                    id = non_focused_animation
                }
            )
        end
    end
end

function on_message(self, message_id, message, sender)
    if (message_id == hashes.cell.set_block) then
        msg.post(
            self.block, "play_animation", {
                id = hashes.cell.animation[message.block]
            }
        )
    elseif (message_id == hashes.cell.disable_block) then
        msg.post(self.block, "disable")
    elseif (message_id == hashes.cell.place_block) then
        -- We will start a new animation for every placement.
        GAME_STATE:pushToPlayerProp(self.player, "is_moving")

        msg.post(
            self.block, "play_animation", {
                id = hashes.cell.animation[message.block]
            }
        )
        msg.post(self.block, "enable")

        local animation = {
            easing = go.EASING_OUTBACK,
            time = 0.15
        }
        if message.animation then
            animation = message.animation
        end

        if message.from_position then
            -- We want to first reset any ongoing block animations.
            go.cancel_animations(self.block, "position")

            if self.is_animating then
                GAME_STATE:removeFromPlayerProp(self.player, "is_moving")
            end
            go.set_position(go.get_position(), self.block)

            -- Define a new animation for the just placed block.
            self.is_animating = true
            go.animate(
                self.block, "position", go.PLAYBACK_ONCE_BACKWARD, message.from_position, animation.easing,
                    animation.time, 0, function()
                        GAME_STATE:removeFromPlayerProp(self.player, "is_moving")
                        self.is_animating = false
                    end
            )
        else
            GAME_STATE:removeFromPlayerProp(self.player, "is_moving")
        end
    elseif (message_id == hashes.cell.set_focus) then
        self.focused = message.focus
    elseif (message_id == hashes.cell.set_highlight) then
        self.highlighted = message.highlight
    elseif (message_id == hashes.cell.set_match) then
        -- We will start a new animation for every matched block.
        GAME_STATE:pushToPlayerProp(self.player, "is_matching")
        self.matched = message.matched

        if self.matched then
            go.animate(
                self.block, "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(0.5), go.EASING_OUTELASTIC, 0.5, 0,
                    function()
                        msg.post(self.block, "disable")
                        go.set_scale(vmath.vector3(1), self.block)
                        self.matched = false
                        GAME_STATE:removeFromPlayerProp(self.player, "is_matching")
                    end
            )
        end
    end
end
