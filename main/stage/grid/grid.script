local game_grid = require "modules.game_grid"
local GAME_STATE = require "modules.game_state"
local hashes = require "modules.hashes"
local collider = require "modules.collider"
local cell_controller = require "modules.cell_controller"

go.property("cell_size", 60)
go.property("gap", 5)
go.property("rows", 7)
go.property("cols", 7)
go.property("parent", msg.url())

function init(self)
    msg.post(".", "acquire_input_focus")
    self.grid = game_grid.generate(self.cell_size, self.gap, self.rows, self.cols, 0, 0)

    self.grid:generateCells()

    go.set_parent(go.get_id(), self.parent)

    self.grid:forEachCell(function(cell)
        cell.instance = factory.create("#cell_spawner", cell.props.pos)
        go.set_parent(cell.instance, go.get_id())
        msg.post(cell.instance, "set_block", {
            block = cell.props.block
        })
        label.set_text(msg.url(nil, cell.instance, "index"), cell.props.index_x .. "," .. cell.props.index_y)
    end)

    self.cell_focus = nil
    self.selected_block = nil
    self.grabbing = false
end

function update(self, dt)
end

function on_input(self, action_id, action)
    local grid_world_pos = go.get_world_position()

    if action_id == hashes.input.touch then
        if action.pressed then
            self.grabbing = true
        elseif action.released then
            self.grabbing = false
        end
    end

    if (collider.coordTouchsRectangle(action.x, action.y, grid_world_pos, self.grid.width, self.grid.height)) then
        -- pointer is inside grid
        local x_index, y_index = self.grid:getFocusIndex(action, grid_world_pos)

        if (self.grabbing and self.selected_block == nil) then
            self.selected_block = cell_controller.selectBlock(self.grid.cells, action, x_index, y_index)
        end

        self.cell_focus = cell_controller.updateFocus(self.cell_focus, self.grid.cells, x_index, y_index)

    elseif (self.cell_focus) then
        -- pointer is out of grid
        self.cell_focus = cell_controller.resetFocus(self.cell_focus, self.grid.cells)
    end

    -- update selecte block position to keep it on the cursor
    if self.selected_block then
        go.set_position(vmath.vector3(action.x, action.y, 0), self.selected_block.instance)
    end

    -- click released anywhere in the screen, we place any block selected back to its place
    if (not self.grabbing and self.selected_block) then
        self.selected_block = cell_controller.placeBlock(self.grid.cells, self.selected_block)
    end
end

function on_message(self, message_id, message, sender)
    if (message_id == hashes.game_state.sync_state) then
        GAME_STATE.grid[message.side].width = self.grid.width
        GAME_STATE.grid[message.side].height = self.grid.height

        GAME_STATE:sendEvent("state_synced", {
            side = message.side
        })
    end
end
