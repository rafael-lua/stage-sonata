local game_grid = require "modules.game_grid"
local GAME_STATE = require "modules.game_state"
local hashes = require "modules.hashes"
local collider = require "modules.collider"
local cell_controller = require "modules.cell_controller"

go.property("cell_size", 60)
go.property("gap", 5)
go.property("rows", 7)
go.property("cols", 7)
go.property("parent", msg.url())

function init(self)
    msg.post(".", "acquire_input_focus")
    self.grid = game_grid.generate(self.cell_size, self.gap, self.rows, self.cols, 0, 0)

    self.grid:generateCells()

    go.set_parent(go.get_id(), self.parent)

    self.grid:forEachCell(function(cell)
        cell.instance = factory.create("#cell_spawner", cell.props.pos)
        go.set_parent(cell.instance, go.get_id())
        msg.post(cell.instance, "set_block", {
            block = cell.props.block
        })
        label.set_text(msg.url(nil, cell.instance, "index"), cell.props.index_x .. "," .. cell.props.index_y)
    end)

    self.cell_focus = nil
end

function update(self, dt)
end

function on_input(self, action_id, action)
    local grid_world_pos = go.get_world_position()

    if (collider.coordTouchsRectangle(action.x, action.y, grid_world_pos, self.grid.width, self.grid.height)) then
        local x_index, y_index = self.grid:getFocusIndex(action, grid_world_pos)

        if action_id == hashes.input.touch then
            pprint("pressed")
        end

        self.cell_focus = cell_controller.updateFocus(self.cell_focus, self.grid.cells, x_index, y_index)
    elseif (self.cell_focus) then
        self.cell_focus = cell_controller.resetFocus(self.cell_focus, self.grid.cells)
    end

    -- self.grid:forEachCell(function(cell)
    -- end)
end

function on_message(self, message_id, message, sender)
    if (message_id == hashes.game_state.sync_state) then
        GAME_STATE.grid[message.side].width = self.grid.width
        GAME_STATE.grid[message.side].height = self.grid.height

        GAME_STATE:sendEvent("state_synced", {
            side = message.side
        })
    end
end
